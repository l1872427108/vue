(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{415:function(e,t,r){"use strict";r.r(t);var p=r(56),v=Object(p.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"vue3-0为什么要用-proxy"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0为什么要用-proxy"}},[e._v("#")]),e._v(" Vue3.0为什么要用 proxy")]),e._v(" "),r("p",[e._v("在 Vue2 中，Object.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等 处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截")]),e._v(" "),r("p",[e._v("不需用使用 Vue.$set 或 Vue.$delete 触发响应式。")]),e._v(" "),r("p",[e._v("全方位的数组变化检测，消除了 Vue2 无效的边界情况。")]),e._v(" "),r("p",[e._v("支持 Map，Set，WeakMap 和 WeakSet。")]),e._v(" "),r("p",[e._v("Proxy 实现的响应式原理与 Vue2 的实现原理相同，实现方式大同小 异∶")]),e._v(" "),r("p",[e._v("get 收集依赖")]),e._v(" "),r("p",[e._v("Set、delete 等触发依赖")]),e._v(" "),r("p",[e._v("对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执 行依赖相关的收集或触发逻辑。")])])}),[],!1,null,null,null);t.default=v.exports}}]);
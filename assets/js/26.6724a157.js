(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{424:function(t,n,e){"use strict";e.r(n);var a=e(56),s=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"vue实例挂在的过程发生了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue实例挂在的过程发生了什么"}},[t._v("#")]),t._v(" Vue实例挂在的过程发生了什么")]),t._v(" "),e("p",[t._v("options 是用户传递过来的配置项，如data、methods等常用的方法")]),t._v(" "),e("p",[t._v("vue构建函数调用_init方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("initMixin")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Vue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("     "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义 _init")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("stateMixin")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Vue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义 $set $get $delete $watch 等")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("eventsMixin")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Vue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义事件  $on  $once $off $emit")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("lifecycleMixin")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Vue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义 _update  $forceUpdate  $destroy")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("renderMixin")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Vue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义 _render 返回虚拟dom")]),t._v("\n")])])]),e("h3",{attrs:{id:"initmixin"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#initmixin"}},[t._v("#")]),t._v(" initMixin")]),t._v(" "),e("p",[t._v("该方法在Vue原型上定义了_init方法")]),t._v(" "),e("p",[t._v("合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法")]),t._v(" "),e("ul",[e("li",[t._v("在调用beforeCreate之前, 数据初始化并未完成，像data、props这些属性无法访问到")]),t._v(" "),e("li",[t._v("到了created的时候，数据已经初始化完成，能够访问data、props这些属性，但这时候并未完成dom的挂载，因此无法访问到dom元素")]),t._v(" "),e("li",[t._v("挂载方法是调用vm.$mount方法")])]),t._v(" "),e("h3",{attrs:{id:"initstate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#initstate"}},[t._v("#")]),t._v(" initState")]),t._v(" "),e("p",[t._v("初始化组件的watcher列表")]),t._v(" "),e("p",[t._v("初始化props")]),t._v(" "),e("p",[t._v("我们和这里主要看初始化data的方法为initData，它与initState在同一文件上")]),t._v(" "),e("p",[t._v("仔细阅读上面的代码，我们可以得到以下结论：")]),t._v(" "),e("ul",[e("li",[t._v("初始化顺序：props、methods、data")]),t._v(" "),e("li",[t._v("data定义的时候可选择函数形式或者对象形式（组件只能为函数形式）")])]),t._v(" "),e("p",[t._v("上文提到挂载方法是调用vm.$mount方法")]),t._v(" "),e("p",[t._v("阅读上面代码，我们能得到以下结论：")]),t._v(" "),e("ul",[e("li",[t._v("不要将根元素放到body或者html上")]),t._v(" "),e("li",[t._v("可以在对象中定义template/render或者直接使用template、el表示元素选择器")]),t._v(" "),e("li",[t._v("最终都会解析成render函数, 调用compileToFunctions，会将template解析成render函数")])]),t._v(" "),e("p",[t._v("对template的解析步骤大致分为以下几步：")]),t._v(" "),e("ul",[e("li",[t._v("将html文档片段解析成ast描述符")]),t._v(" "),e("li",[t._v("将ast描述符解析成字符串")]),t._v(" "),e("li",[t._v("生成render函数\n生成render函数，挂载到vm上后，会再次调用mount方法")])]),t._v(" "),e("p",[t._v("渲染组件  mountComponent(this, el, hydrating)")]),t._v(" "),e("p",[t._v("调用mountComponent渲染组件\n如果没有获取解析的render函数，则会抛出警告\nrender是解析模板文件生成的")]),t._v(" "),e("p",[t._v("执行beforeMount钩子")]),t._v(" "),e("p",[t._v("// 定义更新函数\nupdateComponent = () => {\n// 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render\nvm._update(vm._render(), hydrating)\n}")]),t._v(" "),e("p",[t._v("监听当前组件状态，当有数据变化时，更新组件\nnew Watcher(vm, updateComponent, noop, {\nbefore () {\nif (vm._isMounted && !vm._isDestroyed) {\n// 数据更新引发的组件更新\ncallHook(vm, 'beforeUpdate')\n}\n}\n}, true /* isRenderWatcher */)")]),t._v(" "),e("p",[t._v("执行beforeMount钩子\n定义updateComponent渲染页面视图的方法\n监听组件数据，一旦发生变化, 触发beforeUpdate生命钩子")]),t._v(" "),e("p",[t._v("updateComponent方法主要执行在vue初始化时声明的render，update方法\nrender的作用主要是生成vnode")]),t._v(" "),e("p",[t._v("定义vue 原型上的render方法\nrender函数来自于组件的option")]),t._v(" "),e("p",[t._v("调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode")]),t._v(" "),e("p",[t._v("_update主要功能是调用patch，将vnode转换为真实DOM，并且更新到页面中")]),t._v(" "),e("p",[t._v("new Vue的时候调用会调用_init方法\n调用$mount进行页面的挂载\n挂载的时候主要是通过mountComponent方法\n定义updateComponent更新函数\n执行render生成虚拟DOM\n_update将虚拟DOM生成真实DOM结构，并且渲染到页面中")])])}),[],!1,null,null,null);n.default=s.exports}}]);
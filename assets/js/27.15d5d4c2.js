(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{425:function(t,e,s){"use strict";s.r(e);var a=s(56),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"vue对象添加新属性界面不刷新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue对象添加新属性界面不刷新"}},[t._v("#")]),t._v(" Vue对象添加新属性界面不刷新")]),t._v(" "),s("p",[t._v("解决方案\nVue 不允许在已经创建的实例上动态添加新的响应式属性")]),t._v(" "),s("p",[t._v("若想要实现数据与视图同步更新，可以采用三种解决方案")]),t._v(" "),s("ul",[s("li",[t._v("Vue.set()")]),t._v(" "),s("li",[t._v("Object.assign()")]),t._v(" "),s("li",[t._v("$forceUpdated()")])]),t._v(" "),s("h3",{attrs:{id:"object-assign"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-assign"}},[t._v("#")]),t._v(" Object.assign")]),t._v(" "),s("p",[t._v("直接使用Object.assign()添加到对象的新属性不会触发更新")]),t._v(" "),s("p",[t._v("应创建一个新的对象，合并原对象和混入对象的属性")]),t._v(" "),s("p",[t._v("如果你发现你自己需要在 Vue 中做一次强制更新, 99.9% 的情况，是你在某个地方做错了事")]),t._v(" "),s("p",[t._v("$forceUpdate迫使 Vue 实例重新渲染")]),t._v(" "),s("p",[t._v("仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。")])])}),[],!1,null,null,null);e.default=v.exports}}]);